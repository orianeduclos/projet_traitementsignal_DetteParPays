---
title: "Traitement des données de la dette par pays"

subtitle: | 
    | Traitement du signal et des images
    | Université de Rennes II : Master Mathématiques Appliquées, Statistiques 
author: | 
    | Margaux Bailleul
    | Oriane Duclos
    

date: "`r format(Sys.time(), '%d %B, %Y')`"
geometry: "left=2.5cm,right=2.5cm,top=2cm,bottom=2cm"
fontfamily: mathpazo
output:
  pdf_document:
    keep_tex: true
    latex_engine: pdflatex
    fig_caption: yes
    highlight: haddock
    number_sections: yes
    toc: yes
    toc_depth: 2
    citation_package: natbib
---

# Environnement de travail 

```{r}
library(fda)
library(dplyr)
library(tidyverse)
```

# Introduction

Ce projet vise à sélectionner et analyser un jeu de données fonctionnelles inédit, effectuer un lissage des données si nécessaire, puis appliquer et interpréter des méthodes de statistique exploratoire telles que la moyenne, la variance, la covariance, la corrélation et l'analyse en composantes principales (ACP) fonctionnelle.

Notre étude se focalise sur la dette de divers pays dans le monde sur une période de 31 ans, allant de 1990 à 2021. La base de données initiale comprend 176 pays, mais nous avons décidé de restreindre notre analyse aux pays sans données égales à zéro, afin d'éviter tout biais. Ainsi, nous avons retenu 46 pays pour notre étude.

Le jeu de données utilisé pour cette étude peut être retrouvé à l'adresse suivante : https://www.kaggle.com/datasets/mathurinache/detteparpays


# Prétaitement des données

```{r}
data <- read.csv("archive/Dette_parpays.csv", header = TRUE)
head(data)
```


```{r}
# Suppression des colonnes 'Region' et 'Image.URL' 
data <- data[, !(names(data) %in% c("region", "Image.URL"))]

for (colname in names(data)) {
  # Vérifie si le nom de la colonne commence par 'X' suivi de 4 chiffres
  if (grepl("^X[0-9]{4}$", colname)) {
    # Suppression des virgules et conversion en numérique
    data[[colname]] <- as.numeric(gsub(",", ".", data[[colname]]))

    # Renommage de la colonne pour enlever le 'X'
    names(data)[names(data) == colname] <- substr(colname, 2, nchar(colname))
  }
}

#head(data)
```

Notons que nous avons choisit de prendre que les pays avec des données non nulles. En effet, nous avons remarqué que certains pays avaient des données nulles sur certaines années. Nous avons donc décidé de ne pas prendre en compte ces pays pour notre étude. Il nous reste ainsi 46 pays à étudier.

```{r}
library(tidyr)

long_data <- pivot_longer(data, cols = -Country.Name, names_to = "Année", values_to = "Dette")

df <- pivot_wider(long_data, names_from = Country.Name, values_from = Dette)
df <- as.data.frame(df)

# Mettre la colonne année en rownames
rownames(df) <- df$Année

# enlever la colonne année
df <- df[, !(names(df) %in% c("Année"))]

# enlever toutes les colonnes qui ont au moins un 0 dans la colonne
df <- df[, colSums(df == 0) == 0]
head(df)

```

```{r}
summary(df)
```

Nous allons observer la dette de la France entre 1990 et 2021

## Dette de la France 

```{r}
df_copie <- df
# Utiliser les rownames comme variable pour les années
df_copie$Annee <- as.numeric(rownames(df_copie))

# Filtrer le data frame pour ne conserver que les données de la France
df_france <- df_copie[, c("Annee", "France")]

# Convertir le data frame en format long avec tidyr
df_france_long <- gather(df_france, key = "Pays", value = "Dette", -Annee)

# Créer le ggplot
ggplot(df_france_long, aes(x = Annee, y = Dette)) +
  geom_line() +
  labs(title = "Dette de la France au fil du temps",
       x = "Année",
       y = "Dette") +
  theme_minimal()
```

De 1990 à 2000, la dette augmente de manière relativement douce. Puis, la courbe semble plus plate, indiquant un ralentissement de l'augmentation de la dette ou une période de stagnation. Entre les années 2005 et 2010, il y a une augmentation rapide de la dette, ce qui pourrait correspondre à la crise financière mondiale de 2008 et ses répercussions économiques.Autour de l'année 2015, la dette semble atteindre un plateau, suivie d'une légère diminution qui pourrait indiquer des mesures d'austérité ou une croissance économique améliorant la capacité de la France à gérer sa dette. Vers la fin de la période, la dette semble augmenter de nouveau, ce qui pourrait être lié à des événements économiques récents, comme la crise du COVID-19 qui a nécessité des dépenses gouvernementales accrues pour soutenir l'économie.


## Courbe évolutive/Boxplot des pays retenus

```{r}
# Reorganisation du df pour faciliter la premiere visualisation
years <- 1990:2021
ndf <- cbind(years,df)
data_longer <-  ndf%>%pivot_longer(!years, names_to="pays", values_to="Dette")
head(data_longer)
```


```{r}
library(ggplot2)
ggplot(data_longer, aes(x=years, y=Dette, color=pays)) + geom_line() +  
  xlab("Années") +
  ylab("Dette") +
  ggtitle("Figure 1:  Dette  pour chaque pays au cours du temps ")
```

Ce graphique représente l'évolution de la dette de différents pays au fil du temps. L'axe des ordonnées indique le niveau de dette tandis que l'axe des abscisses représente les années de 1990 à 2021.

On observe une grande variabilité dans les trajectoires de la dette des différents pays. Certains montrent des pics très élevés, indiquant une augmentation significative de la dette pendant certaines périodes, tandis que d'autres présentent des trajectoires plus stables. La diversité des tendances suggère des contextes économiques très différents. Nous pouvons observer que certains pays se démarquent des autres, tels que le Japon (dont la dette n’a cessé d’augmenter) et les Seychelles qui ont eu un pic aux alentours des années 2000.


```{r}
ggplot(data = data_longer,aes(x =pays, y = Dette)) +
  geom_boxplot() +
  xlab("Pays") +
  ylab("Distribution de la variable d'intérêt")+
  coord_flip()+ 
  ggtitle("Figure 2: Boxplot comparatifs")
```

# Lissage pénalisé des courbes 

```{r}
#  Transformation du df en matrice
y=data.matrix(df)
#y

xrange = range(as.numeric(rownames(y))) # range des années
```


```{r}
splbasis = create.bspline.basis(xrange,norder=6,breaks=years)
gcv = 1:40
for (i in 1:40){
  lambda = exp(i-10)
  fdparTemp = fdPar(splbasis,Lfdobj = 2,lambda=lambda)
  smoothdata = smooth.basis(years,y,fdParobj = fdparTemp)
  gcv[i] = mean(smoothdata$gcv) #n valeur de critere general pour un lambda donnée soit la moyenne 
}
plot(gcv)
which.min(gcv)
```

```{r}
lambda = exp(which.min(gcv)-10) # choix du lambda qui minimise le critere general
lambda
fdparTemp = fdPar(splbasis,Lfdobj = 2,lambda=lambda) 
smoothdata = smooth.basis(years,y,fdParobj = fdparTemp) # # ajustement des données (obj fonctionnnelle qui contient l'ensemble des courbes lisées)
```

```{r}
fhatsmooth = eval.fd(years,smoothdata$fd) # evaluation de l'objet fonctionnel fd
par(mfrow=c(1,2)) 
matplot(years,y,type="l",lty=1,ylab="",main="donnees brutes")
matplot(years,fhatsmooth,type="l",lty=1,ylab="",main="donnees lissees")  # chaque courbe un obj fonctionnelle que nous avons estimé 
```

```{r}
matplot(years,fhatsmooth-y,lty=1,type="l",ylab="residus")
```

# Statistiques descriptives 

## Moyenne fonctionnelle
 
On peut représenter l'évolution "moyenne" des emissions de co2 en traçant la moyenne empirique fonctionnelle.

```{r}
meantemp = mean.fd(smoothdata$fd) #moyenne (objet fonctionnel fd)
meantemp # #obj fonctionnelle (coef dans la base de fonction que nous avons choisit(fonction moyenne ici))
```


```{r}
matplot(fhatsmooth,col="gray",type="l",xlab="Année",ylab="Dette")
lines(meantemp$coefs,lwd=2)
```

## Covariance/Corrélation fonctionelle

### Covariance fonctionelle

```{r}
covtemp = var.fd(smoothdata$fd)
surfcov = eval.bifd(xrange[1]:xrange[2],xrange[1]:xrange[2],covtemp)
```


```{r,echo=FALSE,include=FALSE,message=FALSE,warning=FALSE}
nofColors <- 100
colorFunc <- colorRampPalette(c('blue', 'red'));
colors_   <- colorFunc(nofColors)
z=surfcov
z.centerValues <- (
   z[      -1  ,      -1  ] +
   z[      -1  , -ncol(z) ] +
   z[ -nrow(z) ,      -1  ] +
   z[ -nrow(z) , -ncol(z) ]
) / 4

z.colorBin <- cut(z.centerValues, nofColors);

```



```{r}

persp(surfcov,theta=30,xlab="Années",ylab="Années",zlab="covariance",col=  colors_[z.colorBin],)

```

```{r}
filled.contour(surfcov)
```
Ces deux graphiques ne nous montrent rien de particulier, ce n'est pas forcément étonnant dans la mesure où il n'y a pas forcément de causalité entre les émissions de CO2 des individus entre une année et une autre.

### Corrélation fonctionelle


```{r}
cortemp = cor.fd(xrange[1]:xrange[2],smoothdata$fd)
#renvoie directement la matrice de corrélation emprique évaluée en les points demandés
```


```{r}
persp(cortemp,theta=90,phi=40,xlab="Années",ylab="Années",zlab="corrélation",col=  colors_[z.colorBin],)
```

```{r}
filled.contour(cortemp)
```

## Ecart-type fonctionnel

On peut faire de même pour l'écart-type moyen et le mettre en relation avec l'espérance moyenne.
 
```{r}
sdtemp = sd.fd(smoothdata$fd) #ecart-type (objet fonctionnel fd)
```


```{r}
matplot(fhatsmooth,col="gray",type="l",xlab="jours",ylab="temperature")
fnmoy = eval.fd(xrange[1]:xrange[2],meantemp)
fnsd  = eval.fd(xrange[1]:xrange[2],sdtemp)
lines(fnmoy,lwd=2)
lines(fnmoy+2*fnsd,lwd=2,col=4,lty=2)
lines(fnmoy-2*fnsd,lwd=2,col=4,lty=2)
``` 



